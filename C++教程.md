

# 数据类型

有符号、无符号

char

int

short

long

long long



浮点数float double   long double

转义字符

# 变量

变量命名规则

变量的定义和初始化

# 修饰符



# 变量



# 常量



# 运算符



# 循环和判断



# 函数



# 数组



# 字符串



# 指针



# 引用





# 结构体struct

C/C++ 数组允许定义可存储相同类型数据项的变量，但是`结构体`是 C++ 中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。

## 结构体的定义

```c++
struct type_name 
{ 
    member_type1 member_name1; 
    member_type2 member_name2; 
    member_type3 member_name3; 
};
```



# 类与对象class



## 类的创建



## 类的访问权限



## 构造函数



## 析构函数



## 拷贝构造函数



## 静态成员





# 浅拷贝和深拷贝

两个指针指向同一块内存



- strcpy(char* des,const char* source)

把从src地址开始且含有NULL结束符的字符串复制到以dest开始的地址空间

说明：src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串。



- memcpy （void* _Dst,void const* _Src,size_t _Size）

  作用：将Src数组中的内容复制Size个字节长度，给到Dst数组。

  注意:指针是用void修饰的，所以_Dst和_Src两个指针都是由原有的数据类型强制转换为void类型进行操作的，这样，不同类型之间就可以进行复制传值操作了，但是要注意的一点是，不同类型之间的数据长度不同，所以在复制时候要注意匹配相同的数据长度。此外，在进行处理时，最好采用16进制的方式去操作，这样理解起来更为直观。

```c++
char a[8]={0x12,0x34,0x56,0x78,0x90,0x14,0x52,0x46 };
short b=0;
memcpy(&b,a+1,2);
printf("b=%x", b);
```

此段代码的作用是把0x34和0x56拼接起来送到b，输出的最终结果是：0x5634。
输出用的是%x，表示以十六进制进行输出。
char型数据占用一个字节，而short型数据占用两个字节，所以把char型数据拷贝到short型数据中时，传递的字节长度是2，如果把char型数据传递给int型数据，传递的字节长度应该是4。
拼接的时候低字节放在低位，高字节放在高位。
此外，memset函数在对数组进行赋值的过程中，在dest的末尾不会追加结束符’\0’，因此，在使用此函数时，一般不要把目标数组全部占用，留一位写’\0’.



# 友元

如果要访问类的私有成员变量，调用类的公有成员函数是唯一的办法，而类的私有成员函数则无法访问。

友元提供了另一访问类的私有成员的方案。友元有三种：

- 友元全局函数。

- 友元类。

- 友元成员函数。

1）友元全局函数

 在友元全局函数中，可以访问另一个类的所有成员。

2）友元类

在友元类所有成员函数中，都可以访问另一个类的所有成员。

友元类的注意事项：

- 友元关系不能被继承。

- 友元关系是单向的，不具备交换性。

若类B是类A的友元，类A不一定是类B的友元。B是类A的友元，类C是B的友元，类C不一定是类A的友元，要看类中是否有相应的声明。

3）友元成员函数

在友元成员函数中，可以访问另一个类的所有成员。

如果要把男朋友类CBoy的某成员函数声明为超女类CGirl的友元，声明和定义的顺序如下：

class CGirl;      // 前置声明。  

class CBoy { ...... };   // CBoy的定义。

class CGirl { ...... };   // CGirl的定义。            

// 友元成员函数的定义。        

void CBoy::func(CGirl &g) { ...... }    



# 运算符重载

## 重载关系运算符+-*/

## 重载左移运算符

## 重载下标运算符

## 重载赋值运算符

## 重载new&delete运算符

## 重载括号运算符

## 重载一元运算符



# 内存池



# 继承

## 继承的定义

继承可以理解为一个类从另一个类获取成员变量和成员函数的过程。

语法：

class 派生类名:［继承方式］基类名

{

  派生类新增加的成员

}; 

被继承的类称为基类或父类，继承的类称为派生类或子类。



# 自动推导auto



# 函数模板

## 函数模板的基本概念

函数模板是通用的函数描述，使用任意类型（泛型）来描述函数。

编译的时候，编译器推导实参的数据类型，根据实参的数据类型和函数模板，生成该类型的函数定义。

生成函数定义的过程被称为实例化。

创建交换两个变量的函数模板：

```c++
template <typename T>
void Swap(T &a, T &b)
{
   T tmp = a;
   a = b;
   b = tmp;
}
```

函数模板实例化可以让编译器自动推导，也可以在调用的代码中显式的指定。

## 函数模板的具体化



## 函数模板的分文件编写



## 函数模板高级

decltype关键字

函数后置返回类型

# 模板类

## 模板类的基本概念

类模板是通用类的描述，使用任意类型（泛型）来描述类的定义。

函数模板建议用typename描述通用数据类型，类模板建议用class。

```c++
template <class T>
class 类模板名
{
   类的定义;
};
```

## 栈



## 数组



## 嵌套使用模板类（二维容器）



## 模板类具体化

模板类具体化（特化、特例化）有两种：完全具体化和部分具体化。

具体化程度高的类优先于具体化程度低的类，具体化的类优先于没有具体化的类。



## 模板类与继承

1）模板类继承普通类（常见）。

2）普通类继承模板类的实例化版本。

3）普通类继承模板类。(常见)

4）模板类继承模板类。

5）模板类继承模板参数给出的基类（不能是模板类）。





# vector

vector的元素不仅仅可以是int,double,string,还可以是结构体，但是要注意：结构体要定义为全局的，否则会出错。

```c++
#include <iostream>        // 包含头文件。
#include<string>
#include <iomanip>
#include<vector>			//导入vector头文件
using namespace std;        // 指定缺省的命名空间。


int main()
{
	vector<int> v1(10); 	//初始v1内为10个0
	int nSize = v1.size();  //v1的元素个数

	for (int i = 0; i < 10; i++){
		v1[i] = i;                //逐个赋值
	}

	for (int i = 0; i < nSize; i++)  //逐个输出
	{
		cout << v1[i] << " ";
	}
	cout << endl;


	system("pause");
	return 0;

}



```

## 初始化

```c++
vector<int> v1;            //对v1执行默认初始化
vector<int> v2(v1);        //v2初始化为包含v1的所有元素的拷贝
vector<int> v3(n,x);       //v3包括了n个元素，都为x(x可省略)，也可以使用{}代替()
vector<int> v4 = (1,2,3....)    //v4初始化为(1，2，3...)

```



## 下标访问、修改元素

```c++
for (int i = 0; i < nSize; i++)  //逐个输出
	{
		cout << v1[i] << " ";
	}
	cout << endl;

for (int i = 0; i < 10; i++){
		v1[i] = i;                //逐个赋值
	}
```



## 向量尾部插入/删除元素

```c++
vector<int> v2;
	for (int i = 0; i<10; i++){
		v2.push_back(i);            //末尾逐个添加元素
	}

v2.pop_back();		////直接删除队尾最后一个的元素
```



## 使用迭代器访问元素

```cpp
vector<int>::iterator it;
for(it=array.begin();it!=array.end();it++)
    cout<<*it<<endl;
```



```c++
vector<int> v1;
vector<int> v2;
v1.insert(v1.begin(),x);        //在v1开始位置插入x
v1.insert(v1.begin(),n,x);      //在v1结束位置插入n个x
v1.insert(v1.begin(),v2.begin(),v2.end());    //将v2整个插入v1开始位置
```



```c++
v1.empty()           //如果v1为空返回真，否则假
v1.clear()           //清空v1，使其为空
v1.size()            //返回v1的大小
v1.remove(x)         //移除所有大小等于x的元素，但不会改变容器的大小
v1.erase(v1.begin()+2)    //删除v1的第三个元素，总size减1，并且返回下一个元素的迭代器
v1 == v2                  //当v1与v2元素数量与大小相同时为真
a.resize(10); //将a的现有元素个数调至10个，多则删，少则补，其值随机
a.resize(10,2); //将a的现有元素个数调至10个，多则删，少则补，其值为2
a.reserve(100); //将a的容量（capacity）扩充至100
a.swap(b); //将a中的元素和b中的元素进行整体性交换
向量的比较操作 == != >= <= > <  
a==b;
    
    
    
```



## 排序、查找操作（需要导入algorithm）

```c++
//下面函数需要引入 algorithm
#include<algorithm>

sort(v1.begin(),v1.end());        //对整个v1进行排序（从小到大）
sort(v1.rbegin(),v1.rend());      //对整个v1进行排倒序（从大到小）

find(a,b,x)                          //在a到b范围内寻找值为x的对象，
i=find(v1.begin(),v1.end(),x)        //在v1中寻找是否有值为5的存在
                            //找到则返回该位置的迭代器，没有则返回结束位置下一个的迭代器
i-v1.begin()                //如果找到，该式则为该元素位置
```



